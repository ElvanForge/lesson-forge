package handler

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/ElvanForge/lesson-forge/backend/logic"
	"github.com/jackc/pgx/v5/pgxpool"
)

var pool *pgxpool.Pool

func Handler(w http.ResponseWriter, r *http.Request) {
	if pool == nil {
		p, err := pgxpool.New(context.Background(), os.Getenv("DATABASE_URL"))
		if err != nil {
			log.Printf("DB INIT ERROR: %v", err)
			http.Error(w, "Database connection failed", 500)
			return
		}
		pool = p
	}

	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "POST, GET, OPTIONS")
	w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

	if r.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	path := strings.TrimPrefix(r.URL.Path, "/api")
	if path == "/generate" && r.Method == "POST" {
		authMiddleware(http.HandlerFunc(handleGenerate)).ServeHTTP(w, r)
		return
	}
	if path == "/user/credits" && r.Method == "GET" {
		authMiddleware(http.HandlerFunc(handleGetCredits)).ServeHTTP(w, r)
		return
	}
	http.NotFound(w, r)
}

func handleGenerate(w http.ResponseWriter, r *http.Request) {
	userID := r.Header.Get("X-User-ID")
	countryCode := r.Header.Get("x-vercel-ip-country")

	var req struct {
		Prompt         string `json:"prompt"`
		Mode           string `json:"mode"`
		Grade          string `json:"grade"`
		Duration       string `json:"duration"`
		GenerateImages bool   `json:"generateImages"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request", 400)
		return
	}

	cost := 1
	if req.Mode == "ppt" { cost = 2 }

	res, err := pool.Exec(r.Context(), 
		"UPDATE users SET credit_balance = credit_balance - $1 WHERE id = $2::uuid AND credit_balance >= $1", 
		cost, userID)
	if err != nil || res.RowsAffected() == 0 {
		http.Error(w, "Insufficient credits or DB error", 402)
		return
	}

	templatePrompt := fmt.Sprintf(`Act as an expert educator. Create a high-quality lesson plan.
	Topic: %s | Grade Level: %s | Duration: %s
	
	Use this exact Markdown structure:
	# Lesson: [Title]
	## Objectives
	[Bullet points]
	## Summary of Tasks
	[Step-by-step numbered list]
	## Materials & Equipment
	[Checklist style]
	## References
	## Take Home Tasks
	---
	*Generated by Vaelia Forge*`, req.Prompt, req.Grade, req.Duration)

	provider := logic.GetAIProvider(countryCode)
	content, err := provider.GenerateContent(r.Context(), templatePrompt, req.GenerateImages)
	if err != nil {
		pool.Exec(r.Context(), "UPDATE users SET credit_balance = credit_balance + $1 WHERE id = $2::uuid", cost, userID)
		http.Error(w, "AI error", 500)
		return
	}

	var data []byte
	var name string
	var cType string
	if req.Mode == "ppt" {
		data, name, _ = logic.GeneratePPTX(userID, content)
		cType = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
	} else {
		// CHANGE: Save as Markdown (.md) instead of PDF
		data = []byte(content)
		name = "lesson_plan.md"
		cType = "text/markdown"
	}

	uniqueName := fmt.Sprintf("%d_%s", time.Now().Unix(), name)
	url, _ := uploadToSupabase(data, uniqueName, cType)

	// PERSISTENCE FIX: Save to generations table so it appears in history
	_, dbErr := pool.Exec(r.Context(), 
		"INSERT INTO generations (user_id, prompt, file_path, status) VALUES ($1, $2, $3, $4)", 
		userID, req.Prompt, url, "completed")
	
	if dbErr != nil {
		log.Printf("DB SAVE ERROR: %v", dbErr)
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"file": url,
		"raw_content": content,
	})
}

func handleGetCredits(w http.ResponseWriter, r *http.Request) {
	userID := r.Header.Get("X-User-ID")
	var balance int
	pool.QueryRow(r.Context(), "SELECT credit_balance FROM users WHERE id = $1::uuid", userID).Scan(&balance)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]int{"credits": balance})
}

func authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		token := strings.TrimPrefix(r.Header.Get("Authorization"), "Bearer ")
		req, _ := http.NewRequest("GET", os.Getenv("SUPABASE_URL")+"/auth/v1/user", nil)
		req.Header.Set("Authorization", "Bearer "+token)
		req.Header.Set("apikey", os.Getenv("SUPABASE_ANON_KEY"))
		resp, err := (&http.Client{}).Do(req)
		if err != nil || resp.StatusCode != 200 {
			http.Error(w, "Unauthorized", 401)
			return
		}
		var user struct{ ID string `json:"id"` }
		json.NewDecoder(resp.Body).Decode(&user)
		r.Header.Set("X-User-ID", user.ID)
		next.ServeHTTP(w, r)
	})
}

func uploadToSupabase(fileBytes []byte, fileName string, contentType string) (string, error) {
	url := fmt.Sprintf("%s/storage/v1/object/generated-files/%s", os.Getenv("SUPABASE_URL"), fileName)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(fileBytes))
	req.Header.Set("Authorization", "Bearer "+os.Getenv("SUPABASE_SERVICE_ROLE_KEY"))
	req.Header.Set("apikey", os.Getenv("SUPABASE_ANON_KEY"))
	req.Header.Set("Content-Type", contentType)
	(&http.Client{}).Do(req)
	return fmt.Sprintf("%s/storage/v1/object/public/generated-files/%s", os.Getenv("SUPABASE_URL"), fileName), nil
}